# cca_reference.py
# Generate reference signals for CCA analysis

import numpy as np

# -------------------------------------------------------------------------------------------
# Frequency of the presented stimuli, used as a reference for the CCA algorithm
# -------------------------------------------------------------------------------------------
# The code in this segment generates reference signals for CCA analysis based on the input list of stimulus frequencies and sampling rates.
# The reference signals are composed of harmonic signals based on sine and cosine functions, and multiple reference signals are generated by varying the stimulus frequency and number of harmonics.
# The final generated y_ref is a 3D array containing the reference signal data for all targets.

# estimated = test_fbcca(testdata, list_freqs, fs, num_harms, num_fbs);
# Data for the current block- size of test data(num_targs, num_chans, len_gaze_smpl)
#                                               40           9        1000

def cca_reference(list_freqs, fs, num_smpls, num_harms=3):
    """
    Input:
    Parameter for analysis (Modify according to your analysis)
        list_freqs: Frequency List, example: [8:0.5:13.5]
        fs:         Sampling rate, example: 250 Hz
        num_smpls:  Number of samples per target(in an epoch), example: 1000
        num_harms:  Number of harmonics, example: 3, 5...
        
    Output:
        y_ref:     Generated reference signals, (num_freqs, 2*num_harms, num_smpls)
        Structure of y_ref
        1st dimension (num_freqs): represents the number of freqs targets
        2nd dimension (2*num_harms): indicates 6 signals per frequency (each containing sine and cosine, so 2 * num_harms6).
        3rd dimension (num_smpls): indicates that each signal contains n samples.
    """    

    # # Checking Input Parameters
    # if not list_freqs or fs <= 0 or num_smpls <= 0:
    #     raise ValueError("Incomplete or invalid input parameters")
    
    # Number of targets
    num_freqs = len(list_freqs)  

    # Generate time index ranging from 1 to num_smpls(1000), indicating the sampling points in a period.
    tidx = np.arange(1, num_smpls + 1) / fs 

    # Initialize the reference signal matrix
    y_ref = np.zeros((num_freqs, 2 * num_harms, num_smpls), dtype=np.float64)

    for freq_i, stim_freq in enumerate(list_freqs):
        tmp = []
        for harm_i in range(1, num_harms + 1):
            # Generate sin and cos signals for the current frequency and harmonics.
            tmp.append(np.sin(2 * np.pi * harm_i * stim_freq * tidx))
            tmp.append(np.cos(2 * np.pi * harm_i * stim_freq * tidx))
        
        # Add reference signal to y_ref
        y_ref[freq_i, :, :] = np.array(tmp)
    
    # print(f"Shape of y_ref: {y_ref.shape}")
    # print(f"list_freqs: {list_freqs}")
    # print(f"num_freqs: {num_freqs}, num_harms: {num_harms}, num_smpls: {num_smpls}")
    return y_ref

